<p align="center">
    <h1 align="center">API with rate limit</h1>
</p>

Использованные БД:
- Mysql
- Redis

Для ограничения частоты запросов есть предложение сделать гибридное ограничение
+ На стороне Nginx сделать ограничение для критического значения (например: 20 запросов в секунду с одного IP)
либо же использовать CloudFlare и настроить его)
+ Ограничение на стороне PHP (например: 20 запросов в секунду для пользователя)

Выбор схемы зависит от многих факторов

В данном задании, на стороне PHP, я реализовал такие алгоритмы:
* Leacky bucket;
* Sliding Window;

а так же есть возможность реализации других алгоритмов.
  
Sliding Window - более оптимальный алгоритм, в отличии от Leacky Bucket, так как на основе рассчетов дает адекватный 
ответ на резкие всплески запросов, а так же, как и Leacky Bucket не требует сложных и тяжелых нагрузок на систему, 
для обработки запросов.

Путем не сложных изменений, есть возможность сделать ограничение для конкретных экшенов.

Сделана замена первоначальных ключей, для того, что бы не отдавать конечным пользователям прямые названия столбцов

Так как не было конкретики по поводу API Key + API Id, то мной было принято решение использовать:
* Key как "общий ключ компании";
* Id как определенный ключ пользователя;

Это было принято для того, что бы конечный пользователь, не видел информацию другого пользователя.
Соответственно, было принято решение и добавить userId в таблицу значений от пользователей

На этой почве был сделан составной индекс (userId+typeId+typeValue), так как в данной версии API 
(v1 - название для того, что бы можно было расширять данный API, сохраняя при этом обратную совместимость)
данные достаются из таблицы по 3 колонкам.

Так же, можно было бы сделать typeId в виде tinyint - для того, что бы таблица и индекс меньше весили, а так же более 
высокая скорость поиска по таблице.

P.S. Если возникнут какие-то вопросы или непонимание, принятых мною решений, с радостью отвечу на любые вопросы :)

Затрачено часов: 30